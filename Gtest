from dataclasses import dataclass
from typing import Iterable, List, Tuple, Dict, Optional, Any, Union
import re
from openpyxl import load_workbook
import pandas as pd

@dataclass
class SectionPair:
    name: str
    start: Union[str, re.Pattern]
    end: Union[str, re.Pattern]
    match_mode: str = "contains"  # 'contains' | 'equals' | 'regex'

@dataclass
class FoundSection:
    sheet_name: str
    section_name: str
    start_row: int
    end_row: int
    rows: Optional[List[Tuple[Any, ...]]] = None
    dataframe: Optional[pd.DataFrame] = None

class ExcelSectionExtractor:
    def __init__(self, pairs: Iterable[SectionPair], use_row_join: bool = False):
        self.pairs: List[SectionPair] = []
        self.use_row_join = use_row_join

        for p in pairs:
            if p.match_mode not in {"contains", "equals", "regex"}:
                raise ValueError("match_mode must be 'contains', 'equals', or 'regex'")
            if p.match_mode in {"contains", "equals"}:
                p.start = p.start.lower()
                p.end = p.end.lower()
            else:  # regex
                if not isinstance(p.start, re.Pattern):
                    p.start = re.compile(p.start)
                if not isinstance(p.end, re.Pattern):
                    p.end = re.compile(p.end)
            self.pairs.append(p)

    def _row_as_string(self, row: Tuple[Any, ...]) -> str:
        return " ".join(str(c) for c in row if c is not None)

    def _match_start_on_row(self, row, row_str_lower, pair: SectionPair) -> bool:
        if pair.match_mode == "regex":
            hay = row_str_lower if self.use_row_join else self._row_as_string(row)
            return bool(pair.start.search(hay))
        if self.use_row_join:
            return pair.start in row_str_lower
        for cell in row:
            if cell is None:
                continue
            s = str(cell).lower()
            if pair.match_mode == "contains" and pair.start in s:
                return True
            if pair.match_mode == "equals" and pair.start == s:
                return True
        return False

    def _match_end_on_row(self, row, row_str_lower, pair: SectionPair) -> bool:
        if pair.match_mode == "regex":
            hay = row_str_lower if self.use_row_join else self._row_as_string(row)
            return bool(pair.end.search(hay))
        if self.use_row_join:
            return pair.end in row_str_lower
        for cell in row:
            if cell is None:
                continue
            s = str(cell).lower()
            if pair.match_mode == "contains" and pair.end in s:
                return True
            if pair.match_mode == "equals" and pair.end == s:
                return True
        return False

    def analyze_file(
        self,
        filepath: str,
        sheet_names: Optional[Iterable[str]] = None,
        return_dataframes: bool = False,
        auto_close: bool = False,
    ) -> Dict[str, List[FoundSection]]:
        wb = load_workbook(filename=filepath, read_only=True, data_only=True)
        try:
            target_sheets = sheet_names if sheet_names is not None else wb.sheetnames
            results: Dict[str, List[FoundSection]] = {}

            for sheet_name in target_sheets:
                if sheet_name not in wb.sheetnames:
                    continue
                ws = wb[sheet_name]
                found: List[FoundSection] = []
                open_sections: Dict[int, int] = {}      # pair_index -> start_row
                row_buffer: Dict[int, List[Tuple[Any, ...]]] = {}
                last_row_idx = 0

                for idx, row in enumerate(ws.iter_rows(values_only=True), start=1):
                    last_row_idx = idx
                    row_str_lower = None
                    if self.use_row_join:
                        row_str_lower = self._row_as_string(row).lower()

                    # 1) detect starts on this row (for pairs not already open)
                    starts_this_row = []
                    for pi, pair in enumerate(self.pairs):
                        if pi not in open_sections and self._match_start_on_row(row, row_str_lower, pair):
                            starts_this_row.append(pi)

                    # initialize newly started buffers (include current row)
                    for pi in starts_this_row:
                        open_sections[pi] = idx
                        row_buffer[pi] = [row]

                    # 2) append this row to buffers of sections that were already open BEFORE this row
                    for pi in list(open_sections.keys()):
                        if pi in starts_this_row:
                            continue  # already initialized
                        row_buffer.setdefault(pi, []).append(row)

                    # 3) detect ends on this row (for pairs that are open)
                    ends_this_row = []
                    for pi in list(open_sections.keys()):
                        pair = self.pairs[pi]
                        if self._match_end_on_row(row, row_str_lower, pair):
                            ends_this_row.append(pi)

                    # finalize ended sections
                    for pi in ends_this_row:
                        rows = row_buffer.pop(pi, [])
                        start_row = open_sections.pop(pi)
                        df = pd.DataFrame(rows) if return_dataframes else None
                        found.append(FoundSection(
                            sheet_name=sheet_name,
                            section_name=self.pairs[pi].name,
                            start_row=start_row,
                            end_row=idx,
                            rows=rows,
                            dataframe=df,
                        ))

                # auto-close remaining open sections if requested
                if auto_close and open_sections:
                    for pi, start_row in list(open_sections.items()):
                        rows = row_buffer.pop(pi, [])
                        df = pd.DataFrame(rows) if return_dataframes else None
                        found.append(FoundSection(
                            sheet_name=sheet_name,
                            section_name=self.pairs[pi].name,
                            start_row=start_row,
                            end_row=last_row_idx,
                            rows=rows,
                            dataframe=df,
                        ))
                        open_sections.pop(pi, None)

                results[sheet_name] = found
            return results
        finally:
            wb.close()
