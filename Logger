"""
execution_logger.py

Decorator for function execution logging.
Features:
- Execution ID (UUID)
- Function name
- Args/kwargs (optional, redactable, JSON-safe)
- Return type (optional)
- Start/end timestamps (UTC)
- Execution time
- Error details
- Hostname and username
- Custom metadata
- Log levels: INFO (success), WARNING (slow), ERROR (exceptions)
- Slow function warnings via threshold
- Supports sync and async functions
- Fail-safe logging
"""

import functools
import inspect
import json
import os
import socket
import time
import traceback
import uuid
import logging
from datetime import datetime, timezone
from typing import Any, Callable, Dict, Optional

def capture_execution(
    log_handler: Callable[[Dict[str, Any], int], None],
    *,
    log_args: bool = True,
    redact: bool = False,
    log_return: bool = True,
    extra: Optional[Dict[str, Any]] = None,
    slow_threshold: Optional[float] = None,
    log_level: Optional[Dict[str, int]] = None
):
    """
    Decorator to capture function execution details with full production features.

    Parameters
    ----------
    log_handler : Callable[[Dict[str, Any], int], None]
        Function that handles the log entry and receives log level.
    log_args : bool, optional (default=True)
        Include args/kwargs in log.
    redact : bool, optional (default=False)
        Replace args/kwargs with "<REDACTED>".
    log_return : bool, optional (default=True)
        Include return type in log.
    extra : dict, optional
        Custom metadata to include in each log entry.
    slow_threshold : float, optional
        Execution time (seconds) to trigger WARNING log.
    log_level : dict, optional
        Dictionary defining log levels for "success", "slow", "exception".
    """

    hostname = socket.gethostname()
    username = os.getenv("USER") or os.getenv("USERNAME") or "unknown"
    extra = extra or {}

    log_level = log_level or {
        "success": logging.INFO,
        "slow": logging.WARNING,
        "exception": logging.ERROR
    }

    def now_iso() -> str:
        return datetime.now(timezone.utc).isoformat()

    def safe_serialize(obj: Any):
        try:
            json.dumps(obj)
            return obj
        except (TypeError, OverflowError):
            return str(obj)

    def make_log_entry(func: Callable, exec_id: str, args, kwargs):
        entry = {
            "execution_id": exec_id,
            "function": func.__qualname__,
            "args": "<REDACTED>" if redact else (safe_serialize(args) if log_args else None),
            "kwargs": "<REDACTED>" if redact else (safe_serialize(kwargs) if log_args else None),
            "error": None,
            "return_type": None,
            "start_time": now_iso(),
            "end_time": None,
            "execution_time": None,
            "hostname": hostname,
            "username": username,
        }
        entry.update(extra)
        return entry

    def decorator(func: Callable):
        is_async = inspect.iscoroutinefunction(func)

        def determine_log_level(exec_time: float, error: Optional[dict]):
            if error:
                return log_level.get("exception", logging.ERROR)
            if slow_threshold and exec_time >= slow_threshold:
                return log_level.get("slow", logging.WARNING)
            return log_level.get("success", logging.INFO)

        if not is_async:
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                exec_id = str(uuid.uuid4())
                start_time = time.perf_counter()
                log_entry = make_log_entry(func, exec_id, args, kwargs)

                try:
                    result = func(*args, **kwargs)
                    if log_return:
                        log_entry["return_type"] = type(result).__name__
                    return result
                except Exception as exc:
                    log_entry["error"] = {
                        "type": type(exc).__name__,
                        "message": str(exc),
                        "traceback": traceback.format_exc()
                    }
                    raise
                finally:
                    log_entry["end_time"] = now_iso()
                    log_entry["execution_time"] = time.perf_counter() - start_time
                    try:
                        level = determine_log_level(log_entry["execution_time"], log_entry["error"])
                        log_handler(log_entry, level)
                    except Exception:
                        pass

            return wrapper

        else:
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs):
                exec_id = str(uuid.uuid4())
                start_time = time.perf_counter()
                log_entry = make_log_entry(func, exec_id, args, kwargs)

                try:
                    result = await func(*args, **kwargs)
                    if log_return:
                        log_entry["return_type"] = type(result).__name__
                    return result
                except Exception as exc:
                    log_entry["error"] = {
                        "type": type(exc).__name__,
                        "message": str(exc),
                        "traceback": traceback.format_exc()
                    }
                    raise
                finally:
                    log_entry["end_time"] = now_iso()
                    log_entry["execution_time"] = time.perf_counter() - start_time
                    try:
                        level = determine_log_level(log_entry["execution_time"], log_entry["error"])
                        log_handler(log_entry, level)
                    except Exception:
                        pass

            return async_wrapper

    return decorator
